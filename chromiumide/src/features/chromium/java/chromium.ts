// Copyright 2024 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import * as fsPromises from 'fs/promises';
import * as os from 'os';
import * as path from 'path';
import * as vscode from 'vscode';
import pLimit from 'p-limit';
import {exec, execOrThrow} from '../../../../shared/app/common/common_util';
import {StatusBar} from './ui';
import {statNoThrow} from './utils';

// A pattern matching a package name declaration in Java source files.
// It is used to scrape a package name from a Java source file without
// formally parsing it into an AST tree.
const PACKAGE_PATTERN = /package\s+([A-Za-z0-9._]*)\s*;/;

/**
 * Information needed to configure the Java compiler to process Java source
 * files in the repository.
 */
export interface CompilerConfig {
  classPaths: string[];
  sourcePaths: string[];
}

/**
 * Schema of *.build_config.json as generated by and documented in
 * build/android/gyp/write_build_config.py.
 */
interface BuildConfig {
  deps_info: BuildConfigDepsInfo;
}

/**
 * Schema of deps_info in *.build_config.json files.
 */
interface BuildConfigDepsInfo {
  // Java source files compiled for this target.
  target_sources_file?: string;
  // The unprocessed jar file generated by this target. It can be a prebuilt
  // one.
  unprocessed_jar_path?: string;
  // Indicates whether this is a prebuilt jar. We can trust the value when it
  // is set, but unfortunately prebuilt jars may be missing this field, e.g.
  // gen/third_party/android_sdk/android_sdk_java.build_config.json.
  is_prebuilt?: boolean;
  // Source jars needed to build targets depending on this target.
  bundled_srcjars?: string[];
}

/**
 * Determines if a source jar file is useful and should be included in the
 * source path.
 */
async function isUsefulSourceJar(
  jarPath: string,
  srcDir: string,
  outDir: string
): Promise<boolean> {
  // JNI placeholder srcjars contain random stubs.
  if (jarPath.endsWith('_placeholder.srcjar')) {
    return false;
  }

  // When building a java_library target (e.g. //chrome/android:chrome_java), a srcjar containing
  // relevant resource definitions are generated first
  // (e.g. gen/chrome/android/chrome_java__assetres.srcjar), and it's included in the source path
  // when building the java_library target. This is how R references are resolved when *.java are
  // compiled with javac.
  //
  // When multiple java libraries are linked into an APK (e.g. //clank/java:chrome_apk), another
  // srcjar containing all relevant resource definitions is generated
  // (e.g. gen/clank/java/chrome_apk__compile_resources.srcjar). Note that *__assetres.srcjar used
  // on compiling java libraries are NOT linked to final APKs. This is how R definitions looked up
  // in the run time are linked to an APK.
  //
  // Then let's talk about IDE's business. We cannot add *__assetres.srcjar to the source path of
  // the language server because many of those srcjars contain identically named R classes
  // (e.g. org.chromium.chrome.R) with different sets of resource names. (Note that we don't
  // explicitly exclude them here, but actually they don't appear in *.build_config.json at all.)
  // Therefore we want to pick a single resource jar that covers all resource definitions in the
  // whole Chromium tree and add it to the source path. An approximation used here is to pick the
  // __compile_resources.srcjar for the main browser binary. This is not perfect though, because
  // there can be some resources not linked into the main browser binary. Ideally we should
  // introduce a GN target producing a resource jar covering all resources across the repository.
  if (jarPath.endsWith('__compile_resources.srcjar')) {
    if (await statNoThrow(path.join(srcDir, 'clank'))) {
      const privateResourcesJarPath = path.join(
        outDir,
        'gen/clank/java/chrome_apk__compile_resources.srcjar'
      );
      return jarPath === privateResourcesJarPath;
    }

    const publicResourcesJarPath = path.join(
      outDir,
      'gen/chrome/android/chrome_public_apk__compile_resources.srcjar'
    );
    return jarPath === publicResourcesJarPath;
  }
  return true;
}

/**
 * Finds the Java source root directory for a Java source file.
 */
async function findSourceRoot(sourcePath: string): Promise<string | undefined> {
  if (!sourcePath.endsWith('.java')) {
    return undefined;
  }

  let content: string;
  try {
    content = await fsPromises.readFile(sourcePath, {encoding: 'utf8'});
  } catch {
    return undefined;
  }

  const match = PACKAGE_PATTERN.exec(content);
  if (!match) {
    return undefined;
  }

  const depth = match[1].split('.').length;
  let sourceRoot = path.dirname(sourcePath);
  for (let i = 0; i < depth; i++) {
    sourceRoot = path.dirname(sourceRoot);
  }
  return sourceRoot;
}

async function processConfigJson(
  jsonPath: string,
  srcDir: string,
  outDir: string,
  // Following arguments will be mutated as we process JSON files.
  classJarSet: Set<string>,
  sourceRootSet: Set<string>,
  sourceJarSet: Set<string>,
  processedSourceDirSet: Set<string>
): Promise<void> {
  const config = JSON.parse(
    await fsPromises.readFile(jsonPath, {encoding: 'utf8'})
  ) as BuildConfig;

  if (config.deps_info.target_sources_file) {
    // If the target is built from source files, add their source roots.
    const sourcesContent = await fsPromises.readFile(
      path.resolve(outDir, config.deps_info.target_sources_file),
      {encoding: 'utf8'}
    );
    for (const sourceFile of sourcesContent.trimEnd().split('\n')) {
      const sourcePath = path.resolve(outDir, sourceFile);
      const sourceDir = path.dirname(sourcePath);
      if (!processedSourceDirSet.has(sourceDir)) {
        processedSourceDirSet.add(sourceDir);
        const sourceRoot = await findSourceRoot(sourcePath);
        if (sourceRoot && sourceRoot !== srcDir) {
          sourceRootSet.add(sourceRoot);
        }
      }
    }
  } else if (
    config.deps_info.unprocessed_jar_path &&
    // If is_prebuilt is not set, we guess it from the jar path. The path is
    // relative to outDir, so it starts with ../ if it points to a prebuilt jar
    // in the chrome source tree.
    (config.deps_info.is_prebuilt ||
      config.deps_info.unprocessed_jar_path.startsWith('../'))
  ) {
    // This is a prebuilt jar file. Add it to the class path.
    classJarSet.add(
      path.resolve(outDir, config.deps_info.unprocessed_jar_path)
    );
  }

  if (config.deps_info.bundled_srcjars) {
    for (const sourceJarRelPath of config.deps_info.bundled_srcjars) {
      const sourceJarPath = path.join(outDir, sourceJarRelPath);
      if (await isUsefulSourceJar(sourceJarPath, srcDir, outDir)) {
        sourceJarSet.add(sourceJarPath);
        continue;
      }
    }
  }
}

async function buildSourceJars(
  sourceJarSet: Set<string>,
  srcDir: string,
  outDir: string,
  output: vscode.OutputChannel,
  token: vscode.CancellationToken
): Promise<void> {
  const sourceJarRelPaths = [];
  const prefix = outDir + '/';
  for (const p of sourceJarSet.values()) {
    if (p.startsWith(prefix)) {
      sourceJarRelPaths.push(p.substring(prefix.length));
    }
  }
  sourceJarRelPaths.sort();

  await execOrThrow(
    path.join(srcDir, 'third_party/depot_tools/autoninja'),
    ['-C', outDir, ...sourceJarRelPaths],
    {cwd: srcDir, logger: output, logStdout: true, cancellationToken: token}
  );
}

async function extractSourceJars(
  sourceJarSet: Set<string>,
  srcDir: string,
  output: vscode.OutputChannel,
  token: vscode.CancellationToken
): Promise<string[]> {
  // Limit the concurrency to the number of available cores.
  const limit = pLimit(os.cpus().length);

  const extractDirPromises: Promise<string>[] = [];

  for (const sourceJar of sourceJarSet.values()) {
    extractDirPromises.push(
      limit(async () => {
        const extractDir = sourceJar + '.extracted-for-vscode';

        // Compare timestamps to avoid extracting source jars on every startup.
        const sourceJarStat = await fsPromises.stat(sourceJar); // must exist
        const extractDirStat = await statNoThrow(extractDir);
        if (extractDirStat && extractDirStat.ctimeMs >= sourceJarStat.mtimeMs) {
          return extractDir;
        }

        output.appendLine(`Extracting ${sourceJar}`);

        await fsPromises.rm(extractDir, {
          force: true,
          recursive: true,
        });
        await fsPromises.mkdir(extractDir);
        await exec(
          path.join(srcDir, 'third_party/jdk/current/bin/jar'),
          ['-x', '-f', sourceJar],
          {
            cwd: extractDir,
            logger: output,
            cancellationToken: token,
          }
        );
        // Remove org.jni_zero placeholders, if any.
        await fsPromises.rm(path.join(extractDir, 'org/jni_zero'), {
          force: true,
          recursive: true,
        });
        return extractDir;
      })
    );
  }

  return await Promise.all(extractDirPromises);
}

/**
 * Processes *.build_config.json files in the output directory.
 */
async function processConfigJsons(
  jsonPaths: string[],
  srcDir: string,
  outDir: string,
  output: vscode.OutputChannel,
  statusBar: StatusBar,
  token: vscode.CancellationToken
): Promise<CompilerConfig> {
  // A set of *.jar paths to be added to the compiler's class paths.
  const classJarSet = new Set<string>();
  // A set of source root directory paths to be added to the compiler's source paths.
  const sourceRootSet = new Set<string>();
  // A set of source jar paths to be added to the compiler's source paths after extracting them.
  const sourceJarSet = new Set<string>();

  // A set of source directory paths we've processed. This is used to process exactly one *.java
  // file within a directory during processConfigJson. Note that this is different from
  // sourceRootSet; processedSourceDirSet contains all source directories
  // (e.g. ../chrome/android/java/src/org/chromium/chrome) while sourceRootSet contains source root
  // directories only (e.g. ../chrome/android/java/src).
  const processedSourceDirSet = new Set<string>();
  for (const jsonPath of jsonPaths) {
    await processConfigJson(
      jsonPath,
      srcDir,
      outDir,
      classJarSet,
      sourceRootSet,
      sourceJarSet,
      processedSourceDirSet
    );
  }

  // Source jars are not built by list_java_targets.py. Build them by ourselves.
  await statusBar.withProgress('Generating source archives...', () =>
    buildSourceJars(sourceJarSet, srcDir, outDir, output, token)
  );

  // The language server cannot read source jars directly. Extract them to temporary directories.
  const sourceJarExtractDirs = await statusBar.withProgress(
    'Extracting generated source archives...',
    () => extractSourceJars(sourceJarSet, srcDir, output, token)
  );

  const classPaths = [...classJarSet];
  classPaths.sort();
  const sourcePaths = [...sourceRootSet, ...sourceJarExtractDirs];
  sourcePaths.sort();
  return {classPaths, sourcePaths};
}

async function buildConfigJsons(
  srcDir: string,
  outDir: string,
  output: vscode.OutputChannel,
  token: vscode.CancellationToken
): Promise<string[]> {
  // list_java_targets.py has a bug where it reports no target when build.ninja is empty and
  // should be generated. Here we build it explicitly to workaround the issue.
  // TODO(crbug.com/385968364): Fix this bug in list_java_targets.py.
  await execOrThrow(
    path.join(srcDir, 'third_party/depot_tools/autoninja'),
    ['-C', outDir, 'build.ninja'],
    {
      cwd: srcDir,
      logger: output,
      logStdout: true,
      cancellationToken: token,
    }
  );

  const result = await execOrThrow(
    path.join(srcDir, 'build/android/list_java_targets.py'),
    [
      '--print-build-config-paths',
      '--nested',
      '--build',
      '--output-directory',
      outDir,
    ],
    {
      cwd: srcDir,
      logger: output,
      cancellationToken: token,
    }
  );

  const jsonPaths = [];
  for (const line of result.stdout.split('\n')) {
    if (line.length === 0) {
      continue;
    }
    const jsonPath = line.split(': ')[1];
    jsonPaths.push(jsonPath);
  }

  return jsonPaths;
}

/**
 * Computes a CompilerConfig to correctly build Chromium Java files.
 *
 * NOTE: This function contains logic depending on details of Chromium's build
 * artifacts, such as the format *.build_config.json. Since they are Chromium
 * build's internal details and Chromium provides no guarantee of their
 * stability, it is desirable to get rid of these logic by establishing a
 * reliable protocol in the Chromium side.
 *
 * @param srcDir Path of the top-level "src" directory of a Chromium tree.
 * @param outDir Path of a Chromium build output directory.
 * @param output Output channel for logging.
 * @param token Token to cancel the function execution.
 * @returns A CompilerConfig that contains information to configure Java
 *     compilers to build Chromium Java code correctly.
 */
export async function computeCompilerConfig(
  srcDir: string,
  outDir: string,
  output: vscode.OutputChannel,
  statusBar: StatusBar,
  token: vscode.CancellationToken
): Promise<CompilerConfig> {
  const configJsonPaths = await statusBar.withProgress(
    'Building Java configurations...',
    () => buildConfigJsons(srcDir, outDir, output, token)
  );
  return await statusBar.withProgress('Processing Java configurations...', () =>
    processConfigJsons(
      configJsonPaths,
      srcDir,
      outDir,
      output,
      statusBar,
      token
    )
  );
}
