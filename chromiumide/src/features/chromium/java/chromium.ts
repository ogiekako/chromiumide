// Copyright 2024 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import * as fsPromises from 'fs/promises';
import * as path from 'path';
import * as vscode from 'vscode';
import {exec} from '../../../../shared/app/common/common_util';
import {statNoThrow} from './utils';

// A pattern matching a package name declaration in Java source files.
// It is used to scrape a package name from a Java source file without
// formally parsing it into an AST tree.
const PACKAGE_PATTERN = /package\s+([A-Za-z0-9._]*)\s*;/;

/**
 * Information needed to configure the Java compiler to process Java source
 * files in the repository.
 */
export interface CompilerConfig {
  classPaths: string[];
  sourcePaths: string[];
}

/**
 * Schema of *.build_config.json as generated by and documented in
 * build/android/gyp/write_build_config.py.
 */
interface BuildConfig {
  deps_info: BuildConfigDepsInfo;
}

/**
 * Schema of deps_info in *.build_config.json files.
 */
interface BuildConfigDepsInfo {
  // Java source files compiled for this target.
  target_sources_file?: string;
  // The unprocessed jar file generated by this target. It can be a prebuilt
  // one.
  unprocessed_jar_path?: string;
  // Indicates whether this is a prebuilt jar. We can trust the value when it
  // is set, but unfortunately prebuilt jars may be missing this field, e.g.
  // gen/third_party/android_sdk/android_sdk_java.build_config.json.
  is_prebuilt?: boolean;
  // Source jars needed to build targets depending on this target.
  bundled_srcjars?: string[];
}

/**
 * Determines if a source jar file is useful and should be included in the
 * source path.
 */
function isUsefulSourceJar(jarPath: string): boolean {
  // JNI placeholder srcjars contain random stubs.
  if (jarPath.endsWith('_placeholder.srcjar')) {
    return false;
  }
  // *__compile_resources.srcjar contains R.java. There are duplicated R.java
  // for production and tests, so try to pick the production one.
  if (
    jarPath.endsWith('__compile_resources.srcjar') &&
    path.basename(jarPath).includes('test')
  ) {
    return false;
  }
  return true;
}

/**
 * Finds the Java source root directory for a Java source file.
 */
async function findSourceRoot(sourcePath: string): Promise<string | undefined> {
  if (!sourcePath.endsWith('.java')) {
    return undefined;
  }

  let content: string;
  try {
    content = await fsPromises.readFile(sourcePath, {encoding: 'utf8'});
  } catch {
    return undefined;
  }

  const match = PACKAGE_PATTERN.exec(content);
  if (!match) {
    return undefined;
  }

  const depth = match[1].split('.').length;
  let sourceRoot = path.dirname(sourcePath);
  for (let i = 0; i < depth; i++) {
    sourceRoot = path.dirname(sourceRoot);
  }
  return sourceRoot;
}

async function processConfigJson(
  jsonPath: string,
  srcDir: string,
  outDir: string,
  output: vscode.OutputChannel,
  token: vscode.CancellationToken,
  // Following arguments will be mutated as we process JSON files.
  classJarSet: Set<string>,
  sourceRootSet: Set<string>,
  sourceDirSet: Set<string>
): Promise<void> {
  const config = JSON.parse(
    await fsPromises.readFile(jsonPath, {encoding: 'utf8'})
  ) as BuildConfig;

  if (config.deps_info.target_sources_file) {
    // If the target is built from source files, add their source roots.
    const sourcesContent = await fsPromises.readFile(
      path.resolve(outDir, config.deps_info.target_sources_file),
      {encoding: 'utf8'}
    );
    for (const sourceFile of sourcesContent.trimEnd().split('\n')) {
      const sourcePath = path.resolve(outDir, sourceFile);
      const sourceDir = path.dirname(sourcePath);
      if (!sourceDirSet.has(sourceDir)) {
        sourceDirSet.add(sourceDir);
        const sourceRoot = await findSourceRoot(sourcePath);
        if (sourceRoot && sourceRoot !== srcDir) {
          sourceRootSet.add(sourceRoot);
        }
      }
    }
  } else if (
    config.deps_info.unprocessed_jar_path &&
    // If is_prebuilt is not set, we guess it from the jar path. The path is
    // relative to outDir, so it starts with ../ if it points to a prebuilt jar
    // in the chrome source tree.
    (config.deps_info.is_prebuilt ||
      config.deps_info.unprocessed_jar_path.startsWith('../'))
  ) {
    // This is a prebuilt jar file. Add it to the class path.
    classJarSet.add(
      path.resolve(outDir, config.deps_info.unprocessed_jar_path)
    );
  }

  // Add source jars to the source roots. Since our language server does not
  // support source jars directly, we extract them to sibling directories.
  if (config.deps_info.bundled_srcjars) {
    for (const sourceJarRelPath of config.deps_info.bundled_srcjars) {
      const sourceJarPath = path.join(outDir, sourceJarRelPath);
      if (!isUsefulSourceJar(sourceJarPath)) {
        continue;
      }
      const sourceJarStat = await statNoThrow(sourceJarPath);
      if (!sourceJarStat) {
        continue;
      }
      const extractDirPath = sourceJarPath + '.extracted-for-vscode';
      if (sourceRootSet.has(extractDirPath)) {
        continue;
      }

      sourceRootSet.add(extractDirPath);

      // Compare timestamps to avoid extracting source jars on every startup.
      const extractDirStat = await statNoThrow(extractDirPath);
      if (extractDirStat && extractDirStat.ctimeMs >= sourceJarStat.mtimeMs) {
        continue;
      }

      // Extract the source jar.
      // TODO: Consider parallelizing this as it is fairly a heavy operation.
      output.appendLine(`Extracting ${sourceJarPath}`);
      await fsPromises.rm(extractDirPath, {
        force: true,
        recursive: true,
      });
      await fsPromises.mkdir(extractDirPath);
      await exec(
        path.join(srcDir, 'third_party/jdk/current/bin/jar'),
        ['-x', '-f', sourceJarPath],
        {
          cwd: extractDirPath,
          logger: output,
          cancellationToken: token,
        }
      );
      // Remove org.jni_zero placeholders, if any.
      await fsPromises.rm(path.join(extractDirPath, 'org/jni_zero'), {
        force: true,
        recursive: true,
      });
    }
  }
}

/**
 * Processes *.build_config.json files in the output directory.
 */
async function processConfigJsons(
  jsonPaths: string[],
  srcDir: string,
  outDir: string,
  output: vscode.OutputChannel,
  token: vscode.CancellationToken
): Promise<CompilerConfig> {
  const classJarSet = new Set<string>();
  const sourceRootSet = new Set<string>();
  const sourceDirSet = new Set<string>();

  // Add the Android source stub jar. It contains function argument names.
  const platformsDir = path.join(
    srcDir,
    'third_party/android_sdk/public/platforms'
  );
  for (const versionDir of await fsPromises.readdir(platformsDir)) {
    const srcJar = path.join(platformsDir, versionDir, 'android-stubs-src.jar');
    if (await statNoThrow(srcJar)) {
      sourceDirSet.add(srcJar);
    }
  }

  for (const jsonPath of jsonPaths) {
    await processConfigJson(
      jsonPath,
      srcDir,
      outDir,
      output,
      token,
      classJarSet,
      sourceRootSet,
      sourceDirSet
    );
  }

  const classPaths = [...classJarSet];
  classPaths.sort();
  const sourcePaths = [...sourceRootSet];
  sourcePaths.sort();
  return {classPaths, sourcePaths};
}

async function buildConfigJsons(
  srcDir: string,
  outDir: string,
  output: vscode.OutputChannel,
  token: vscode.CancellationToken
): Promise<string[]> {
  const result = await exec(
    path.join(srcDir, 'build/android/list_java_targets.py'),
    [
      '--print-build-config-paths',
      '--nested',
      '--build',
      '--output-directory',
      outDir,
    ],
    {
      cwd: srcDir,
      logger: output,
      cancellationToken: token,
    }
  );
  if (result instanceof Error) {
    throw new Error(`list_java_targets.py failed: ${result.message}`);
  }

  const jsonPaths = [];
  for (const line of result.stdout.split('\n')) {
    if (line.length === 0) {
      continue;
    }
    const jsonPath = line.split(': ')[1];
    jsonPaths.push(jsonPath);
  }

  return jsonPaths;
}

/**
 * Computes a CompilerConfig to correctly build Chromium Java files.
 *
 * NOTE: This function contains logic depending on details of Chromium's build
 * artifacts, such as the format *.build_config.json. Since they are Chromium
 * build's internal details and Chromium provides no guarantee of their
 * stability, it is desirable to get rid of these logic by establishing a
 * reliable protocol in the Chromium side.
 *
 * @param srcDir Path of the top-level "src" directory of a Chromium tree.
 * @param outDir Path of a Chromium build output directory.
 * @param output Output channel for logging.
 * @param token Token to cancel the function execution.
 * @returns A CompilerConfig that contains information to configure Java
 *     compilers to build Chromium Java code correctly.
 */
export async function computeCompilerConfig(
  srcDir: string,
  outDir: string,
  output: vscode.OutputChannel,
  token: vscode.CancellationToken
): Promise<CompilerConfig> {
  const configJsonPaths = await buildConfigJsons(srcDir, outDir, output, token);
  return await processConfigJsons(
    configJsonPaths,
    srcDir,
    outDir,
    output,
    token
  );
}
